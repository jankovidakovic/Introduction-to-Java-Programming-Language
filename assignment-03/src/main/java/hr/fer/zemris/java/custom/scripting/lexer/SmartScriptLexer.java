package hr.fer.zemris.java.custom.scripting.lexer;

/**
 * Lexer which tokenizes input document into tokens. Valid document consists of
 * text and tags. Tags are bounded by "{$"(tag beginner) and "$}"(tag ender).
 * Text part of the document is all outside of tag bounds. Each tag has its name.
 * Names of the tag are case-insensitive. for example, name of {$FOR...$} is FOR,
 * but so is the name of {$fOr...$}. Whitespaces are ignored before and after
 * tag names. There are two types of tags - empty and non-empty. Empty tags are
 * those with the name '='. They have no content and do not need the closing tag.
 * Non-empty tags, however, have content. Content is opened by the declaration
 * of non-empty tag, and must be closed by the END-tag, which is defined to be 
 * {$END$}. Since end tag only serves for closing other non-empty tags, it does
 * not have its representation on terms of tokens of this lexer.
 * This lexer produces the tokens that are defined and documented in the 
 * <Â¢ode>SmartScriptToken</code> class.
 * Lexer has different states. State of the lexer are controlled by the client
 * which uses it, and are defined in <code>SmartScriptLexerState</code> enum.
 * State <code>TEXT</code> should be used to tokenize text in the input file,
 * and the beginning of the tag. After that, the lexer should be put in 
 * <code>TAG_NAME</code> state, to read the name of the tag. After that,
 * state <code>TAG_CONTENT</code> should follow, to tokenize the contents of
 * the tag, ending with the tag bound. Finally, the lexer should be put bach
 * into <code>TEXT</code> state, and this cycle should repeat throughout the
 * whole document.
 * Tokens generated by this lexer are described in detail in the documentation
 * of the <code>SmartScriptToken</code> class. One token is extremely special,
 * it is the last token generated by this lexer, which signals the end of input.
 * After that token has been generated, any further attempt to generate new
 * tokens will result in an exception being thrown. Also, lexer will throw
 * and exception if it encounters anything in the input that cannot fit into
 * any token.
 * 
 * @author jankovidakovic
 *
 */
public class SmartScriptLexer {
	//private variables
	private final char[] data;	//text which will be tokenized
	private SmartScriptToken token;	//current token
	private int currentIndex;	//current index in input text
	private SmartScriptLexerState state;	//current lexer state
	
	/**
	 * Initializes the lexer to tokenize given input.
	 *
	 * @param input Input which will be tokenized.
	 */
	public SmartScriptLexer(String input) {
		data = input.toCharArray();
		token = null;
		currentIndex = 0;
		state = SmartScriptLexerState.TEXT;
	}
	
	/**
	 * Skips all the concurrent whitespace starting from the position
	 * of current index.
	 */
	private void skipWhitespace() {
		while (currentIndex < data.length &&
				Character.isWhitespace(data[currentIndex])) {
			currentIndex++;
		}
	}
	
	/**
	 * Generates the next token, depending on the state of the lexer.
	 *
	 * @return next generated token
	 * @throws SmartScriptLexerException if token cannot be generated,
	 * 		for reasons of invalid input or if all input has been processed.
	 */
	public SmartScriptToken nextToken() {
		//check if lexer has already done its job
		if (token != null && token.getType() == SmartScriptTokenType.EOF) {
			throw new SmartScriptLexerException("No more tokens.");
		}
		if (currentIndex >= data.length) { //generate the last token
			token = new SmartScriptToken(SmartScriptTokenType.EOF, null);
			return token;
		}

		//every state is different
		//check if tag name has already been read
		//tag-ender has already been read, lexer is in the wrong state
		switch (state) {
			//read text or tag beginner
			case TEXT -> {
				if (token != null && token.getType() ==
						SmartScriptTokenType.TAG_BEGIN) {
					//after tokenizing tag begin mark, what follows must be a tag
					throw new SmartScriptLexerException("Text was already "
							+ "tokenized. Lexer should be in TAG_NAME state.");
				}
				String text = readValidText(); //could cause exceptions
				if (text.equals("{$")) { //beginning of tag
					token = new SmartScriptToken(
							SmartScriptTokenType.TAG_BEGIN, text);
				} else { //valid text was extracted
					if (text.isBlank() && currentIndex >= data.length) {
						token = new SmartScriptToken(SmartScriptTokenType.EOF, null);
					} else {
						token = new SmartScriptToken(
								SmartScriptTokenType.TEXT, text);
					}

				}
				return token;
			}
			//read tag name
			case TAG_NAME -> {
				if (token != null && token.getType() ==
						SmartScriptTokenType.TAG_NAME) {
					throw new SmartScriptLexerException( //lexer is in wrong state
							"Can only read one tag name.");
				}
				String tagName = readValidTagName(); //could cause exceptions
				token = new SmartScriptToken(SmartScriptTokenType.TAG_NAME, tagName);
				return token;
			}
			//read the tokens inside of the tag
			case TAG_CONTENT -> {
				if (token != null && token.getType() ==
						SmartScriptTokenType.TAG_END) {
					throw new SmartScriptLexerException("Cannot read tag content"
							+ "after tag end, lexer should be in TEXT state.");
				}
				String entry;
				skipWhitespace();
				if (data[currentIndex] == '@') { //try to read function
					entry = readValidFunctionName();
					token = new SmartScriptToken(
							SmartScriptTokenType.FUNCTION, entry);

				} else if (data[currentIndex] == '\"') { //try to read string
					entry = readValidString();
					token = new SmartScriptToken(
							SmartScriptTokenType.STRING, entry);

				} else if (Character.isLetter(data[currentIndex])) { //variable
					entry = readValidVariableName();
					token = new SmartScriptToken(
							SmartScriptTokenType.VARIABLE, entry);

				} else if (data[currentIndex] == '$') { //tag ender
					entry = readValidTagEnd();
					token = new SmartScriptToken(
							SmartScriptTokenType.TAG_END, entry);

				} else if (Character.isDigit(data[currentIndex])) { //number
					entry = readValidNumber();
					try {
						Integer integer = Integer.parseInt(entry);
						token = new SmartScriptToken(
								SmartScriptTokenType.INTEGER, integer);

					} catch (NumberFormatException ex) {
						Double decimal = Double.parseDouble(entry);
						token = new SmartScriptToken(
								SmartScriptTokenType.DOUBLE, decimal);
					}

				} else if (data[currentIndex] == '+' || data[currentIndex] == '*'
						|| data[currentIndex] == '/' || data[currentIndex] == '^') {
					//operator which is not a minus
					entry = readValidOperator();
					token = new SmartScriptToken(
							SmartScriptTokenType.OPERATOR, entry);

				} else if (data[currentIndex] == '-') { //could be start of number
					//or a regular operator
					if (currentIndex + 1 < data.length &&
							Character.isDigit(data[currentIndex + 1])) { //number
						entry = readValidNumber();
						try {
							Integer integer = Integer.parseInt(entry);
							token = new SmartScriptToken(
									SmartScriptTokenType.INTEGER, integer);
						} catch (NumberFormatException ex) { //was not integer
							Double decimal = Double.parseDouble(entry);
							token = new SmartScriptToken(
									SmartScriptTokenType.DOUBLE, decimal);
						}

					} else { //not a number - an operator
						entry = readValidOperator();
						token = new SmartScriptToken(
								SmartScriptTokenType.OPERATOR, entry);
					}
				}
				return token;
			}
			//an error occurred
			default -> throw new SmartScriptLexerException("Lexer is not in a valid state.");
		}
	}
	
	/**
	 * Reads the valid function name, which starts with '@' and continues
	 * with valid variable name.
	 *
	 * @return Function name as represented by a string.
	 * @throws SmartScriptLexerException if function name is not valid.
	 */
	private String readValidFunctionName() {
		String validFunctionName;
		
		if (data[currentIndex] != '@') { //not a valid function name
			throw new SmartScriptLexerException("Invalid function name.");
		}
		try {
			currentIndex++;
			validFunctionName = readValidVariableName();
		} catch (SmartScriptLexerException ex) { //invalid function name
			throw new SmartScriptLexerException("Invalid function name.");
		}
		return validFunctionName;
	}
	
	/**
	 * Reads the valid variable name, which stars with a letter and continues
	 * with sequence of letters, digits, or underscores. Causes exception if
	 * valid name could not be read.
	 *
	 * @return Valid variable name represented by a <code>String</code>.
	 * @throws SmartScriptLexerException if no valid variable name could be read
	 */
	private String readValidVariableName() {
		
		String validVariableName = "";
		
		while (currentIndex < data.length) {
			if (validVariableName.isEmpty()) { //first character must be a letter
				if (Character.isLetter(data[currentIndex])) {
					validVariableName += data[currentIndex];
					currentIndex++;
				} else {
					throw new SmartScriptLexerException("Invalid variable name.");
				}
			} else { //can be a letter, a digit or an underscore
				if (Character.isLetter(data[currentIndex]) ||
						Character.isDigit(data[currentIndex]) ||
						data[currentIndex] == '_') {
					validVariableName += data[currentIndex];
					currentIndex++;
				} else {
					break; //valid variable name ends here
				}
			}
		}
		return validVariableName;
	}
	
	/**
	 * Reads a valid operator, which is a single character and can be :
	 * +(plus), -(minus), *(multiplication), /(division) or ^(exponentiation).
	 * Causes an exception if a valid operator could not be read.
	 *
	 * @return Valid operator, represented by a <code>String</code>
	 * @throws SmartScriptLexerException if no valid operator could be read.
	 */
	private String readValidOperator() {
		String validOperator = "";
		
		if (data[currentIndex] == '+' || data[currentIndex] == '-'
				|| data[currentIndex] == '*' || data[currentIndex] == '/'
				|| data[currentIndex] == '^') {
			validOperator += data[currentIndex];
		} else { //not a valid operator
			throw new SmartScriptLexerException("Invalid operator.");
		}
		currentIndex++;
		return validOperator;
	}
	
	/**
	 * Reads a valid string from inside the tag content String is defined
	 * as a sequence of characters bounded by double quotes. Allowed
	 * escape sequences are '\\'(backslash), '\"'(double quote which is
	 * not the end of the string), '\n'(newline), '\r'(carriage return) 
	 * and '\t'(tab).
	 *
	 * @return valid String name
	 * @throws SmartScriptLexerException if no valid string name could be read.
	 */
	private String readValidString() {
		StringBuilder validString = new StringBuilder();
		if (data[currentIndex] != '\"') { //does not start with a quote
			throw new SmartScriptLexerException("Invalid string.");
		} else {
			currentIndex++; //skip quote
			
			//read until the next quote which is not escaped
			while (currentIndex < data.length && data[currentIndex] != '\"') {
				if (data[currentIndex] == '\\') { //escape sequence
					currentIndex++; //skip backslash in input
					if (currentIndex < data.length) {
						if (data[currentIndex] == '\"' || 
							data[currentIndex] == '\\') {
							validString.append(data[currentIndex]);
						} else if (data[currentIndex] == 'n') {
							validString.append('\n');
						} else if (data[currentIndex] == 'r') {
							validString.append('\r');
						} else if (data[currentIndex] == 't') {
							validString.append('\t');
						} else { //not a valid escape sequence
							throw new SmartScriptLexerException("Invalid string.");
						}
						currentIndex++;
					} else {
						throw new SmartScriptLexerException("Invalid string.");
					}
				} else {
					validString.append(data[currentIndex]);
					currentIndex++;
				}
			}
		}
		//check if escape sequence is not finished and is the last character
		if (currentIndex >= data.length || data[currentIndex] != '\"') {
			throw new SmartScriptLexerException("Invalid string.");
		}
		currentIndex++;	//to skip trailing quote
		return validString.toString();
	}
	
	/**
	 * Reads a valid number from the input. Valid numbers are integers
	 * or doubles. Throws an exception if valid number could not be read.
	 *
	 * @return String representation of read valid number
	 * @throws SmartScriptLexerException it no valid number was read
	 */
	private String readValidNumber() {
		
		StringBuilder validNumber = new StringBuilder();
		
		while (currentIndex < data.length) {
			//check if first comes a minus sign, or a dot is found
			if ((validNumber.length() == 0) && data[currentIndex] == '-' ||
			Character.isDigit(data[currentIndex]) || 
			(Character.isDigit(validNumber.charAt(validNumber.length() - 1))
			&& data[currentIndex] == '.')) {
				
				validNumber.append(data[currentIndex]);
				currentIndex++;
			} else { //check if it's a digit
				if (Character.isDigit(
						validNumber.charAt(validNumber.length() -1))) {
					break;
				} else { //not a digit
					throw new SmartScriptLexerException("Invalid number.");
				}
			}
		}
		return validNumber.toString();
	}
	
	/**
	 * Reads a valid tag ender, which is "$}".
	 *
	 * @return valid tag ender in its String representation.
	 * @throws SmartScriptLexerException if no valid tag ender was read.
	 */
	private String readValidTagEnd() {
		StringBuilder validTagEnd = new StringBuilder();
		
		while (currentIndex < data.length) {
			//check if valid tag ender was not yet read fully
			if ((validTagEnd.length() == 0) && data[currentIndex] == '$' ||
				validTagEnd.toString().endsWith("$") && data[currentIndex] == '}') {
				validTagEnd.append(data[currentIndex]);
				currentIndex++;
			} else if (validTagEnd.toString().endsWith("}") ) { //tag ender was read
				break;
			} else { //no valid tag ender was read
				throw new SmartScriptLexerException("Invalid tag end.");
			}
		}
		return validTagEnd.toString();
	}
	
	/**
	 * Reads a valid tag name, which is any valid variable name.
	 *
	 * @return Uppercase representation of read tag name, because
	 * 	tag names are case-insensitive.
	 * @throws SmartScriptLexerException if no valid tag name could be read.
	 */
	private String readValidTagName() {
		StringBuilder tagName = new StringBuilder();
		skipWhitespace();
		
		while (currentIndex < data.length) {
			if (tagName.length() == 0) { //beginning of tag name
				if (data[currentIndex] == '=') { //valid tag name
					tagName.append(data[currentIndex]);
					currentIndex++;
					break;
					
				} else if (Character.isLetter(data[currentIndex])) {
					//valid beginning of tag name
					tagName.append(data[currentIndex]);
					currentIndex++;
					
				} else { //invalid tag name
					throw new SmartScriptLexerException("Invalid tag name.");
				}
				
			} else { //somewhere in the middle
				
				while (currentIndex < data.length && (
						Character.isLetter(data[currentIndex]) || 
						Character.isDigit(data[currentIndex]) ||
						data[currentIndex] == '_')) {
					
					tagName.append(data[currentIndex]);
					currentIndex++;
				}
				break; 	//tag name was read 
			}
		}
		return tagName.toString().toUpperCase();
	}
	
	/**
	 * Reads valid text, which is everything outside of tag marks in the
	 * document. Allowed escape sequences are '\\' (backslash) and 
	 * '\{' (left curly bracket). Left curly bracket should only be
	 * escaped if it is intended to be followed by '$' sign, because if not,
	 * that combination represents the beginning of a tag and the text reading
	 * will stop there. If Bracket is not followed by the specified sign, it
	 * is treated as a completely normal character.
	 *
	 * @return Valid text, represented as a String.
	 * @throws SmartScriptLexerException if no valid text could be read.
	 */
	private String readValidText() {
		StringBuilder text = new StringBuilder();
		
		skipWhitespace();
		while (currentIndex < data.length) {	//to not go out of bounds
			if (data[currentIndex] == '\\') {	//escape sequence
				currentIndex++;		//let's look at the next character
				if (currentIndex >= data.length) {	//there is none
					throw new SmartScriptLexerException
						("Invalid text escape sequence.");
				}
				if (data[currentIndex] == '\\' ||
				data[currentIndex] == '{') { //valid escape sequence
					text.append(data[currentIndex]);
					currentIndex++;
				} else {	//invalid escape sequence
					throw new SmartScriptLexerException
						("Invalid text escape sequence.");
				}
			} else if (data[currentIndex] == '{') { //maybe tag begins here
				if (currentIndex + 1 < data.length) { //has enough for next char
					if (data[currentIndex+1] == '$') { //tag begins
						if (text.length() == 0) { //tag is the first thing
							text = new StringBuilder("{$");
							currentIndex += 2; //skips the tag mark
						}
						break;
					} else { //tag does not begin, bracket is normal character
						text.append(data[currentIndex]);
						currentIndex++;
					}
				}
			} else { //normal character
				text.append(data[currentIndex]);
				currentIndex++;
			}
		}
		return text.toString();
	}
	
	/**
	 * Sets the state of the lexer to the given state.
	 * Intended to be used by the client which uses the lexer.
	 *
	 * @param state New state of the lexer.
	 */
	public void setState(SmartScriptLexerState state) {
		this.state = state;
	}
	
}
