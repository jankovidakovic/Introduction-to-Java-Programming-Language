package hr.fer.zemris.java.custom.scripting.lexer;

/**
 * Lexer which tokenizes input document into tokens. Valid document consists of
 * text and tags. Tags are bounded by "{$"(tag beginner) and "$}"(tag ender).
 * Text part of the document is all outside of tag bounds. Each tag has its name.
 * Names of the tag are case-insensitive. for example, name of {$FOR...$} is FOR,
 * but so is the name of {$fOr...$}. Whitespaces are ignored before and after
 * tag names. There are two types of tags - empty and non-empty. Empty tags are
 * those with the name '='. They have no content and do not need the closing tag.
 * Non-empty tags, however, have content. Content is opened by the declaration
 * of non-empty tag, and must be closed by the END-tag, which is defined to be 
 * {$END$}. Since end tag only serves for closeing other non-empty tags, it does
 * not have its representation on terms of tokens of this lexer.
 * This lexer produces the tokens that are defined and documented in the 
 * <Â¢ode>SmartScriptToken</code> class.
 * Lexer has different states. State of the lexer are controlled by the client
 * which uses it, and are defined in <code>SmartScriptLexerState</code> enum.
 * State <code>TEXT</code> should be used to tokenize text in the input file,
 * and the beginning of the tag. After that, the lexer should be put in 
 * <code>TAG_NAME</code> state, to read the name of the tag. After that,
 * state <code>TAG_CONTENT</code> should follow, to tokenize the contents of
 * the tag, ending with the tag bound. Finally, the lexer should be put bach
 * into <code>TEXT</code> state, and this cycle should repeat throughout the
 * whole document.
 * Tokens generated by this lexer are described in detail in the documentation
 * of the <code>SmartScriptToken</code> class. One token is extremely special,
 * it is the last token generated by this lexer, which signals the end of input.
 * After that token has been generated, any further attempt to generate new
 * tokens will result in an exception being thrown. Also, lexer will throw
 * and exception if it encounters anything in the input that cannot fit into
 * any token.
 * 
 * @author jankovidakovic
 *
 */
public class SmartScriptLexer {
	//private variables
	private char[] data;	//text which will be tokenized
	private SmartScriptToken token;	//current token
	private int currentIndex;	//current index in input text
	private SmartScriptLexerState state;	//current lexer state
	
	/**
	 * Initializes the lexer to tokenize given input.
	 * @param input Input which will be tokenized.
	 */
	public SmartScriptLexer(String input) {
		data = input.toCharArray();
		token = null;
		currentIndex = 0;
		state = SmartScriptLexerState.TEXT;
	}
	
	/**
	 * Skips all the concurrent whitespace starting from the position
	 * of current index.
	 */
	private void skipWhitespace() {
		while (currentIndex < data.length &&
				Character.isWhitespace(data[currentIndex])) {
			currentIndex++;
		}
	}
	
	/**
	 * Generates the next token, depending on the state of the lexer.
	 * @return next generated token
	 * @throws SmartScriptLexerException if token cannot be generated,
	 * 		for reasons of invalid input or if all input has been processed.
	 */
	public SmartScriptToken nextToken() {
		//check if lexer has already done its job
		if (token != null && token.getType() == SmartScriptTokenType.EOF) {
			throw new SmartScriptLexerException("No more tokens.");
		}
		if (currentIndex >= data.length) { //generate the last token
			token = new SmartScriptToken(SmartScriptTokenType.EOF, null);
			return token;
		}
		
		switch (state) { //every state is different
		case TEXT: //read text or tag beginnner
			if (token != null && token.getType() == 
				SmartScriptTokenType.TAG_BEGIN) {
				//after tokenizing tag begin mark, what follows must be a tag
				throw new SmartScriptLexerException("Text was already "
						+ "tokenized. Lexer should be in TAG_NAME state.");
			}
			
			String text = readValidText(); //could cause exceptions
			if (text == "{$") { //beginning of tag
				token = new SmartScriptToken(
						SmartScriptTokenType.TAG_BEGIN, text);
			} else { //valid text was extracted
				if (text.isBlank() && currentIndex >= data.length)  {
					token = new SmartScriptToken(SmartScriptTokenType.EOF, null);
				} else {
					token = new SmartScriptToken(
							SmartScriptTokenType.TEXT, text);	
				}
					
			}
			
			return token;
			
		case TAG_NAME: //read tag name

			//check if tag name has already been read
			if (token != null && token.getType() == 
											SmartScriptTokenType.TAG_NAME) {
				throw new SmartScriptLexerException( //lexer is in wrong state
						"Can only read one tag name.");
			}
			
			String tagName = readValidTagName(); //could cause exceptions
			token = new SmartScriptToken(SmartScriptTokenType.TAG_NAME, tagName);
			return token;
			
		case TAG_CONTENT: //read the tokens inside of the tag
			
			//tag-ender has already been read, lexer is in the wrong state
			if (token != null && token.getType() ==
					SmartScriptTokenType.TAG_END) {
				throw new SmartScriptLexerException("Cannot read tag content"
						+ "after tag end, lexer should be in TEXT state.");
			}
			
			String entry;
			skipWhitespace();
			
			if (data[currentIndex] == '@') { //try to read function
				entry = readValidFunctionName();
				token = new SmartScriptToken(
						SmartScriptTokenType.FUNCTION, entry);
				
			} else if (data[currentIndex] == '\"') { //try to read string
				entry = readValidString();
				token = new SmartScriptToken(
						SmartScriptTokenType.STRING, entry);
				
			} else if (Character.isLetter(data[currentIndex])) { //variable
				entry = readValidVariableName();
				token = new SmartScriptToken(
						SmartScriptTokenType.VARIABLE, entry);
				
			} else if (data[currentIndex] == '$') { //tag ender
				entry = readValidTagEnd();
				token = new SmartScriptToken(
						SmartScriptTokenType.TAG_END, entry);
				
			} else if (Character.isDigit(data[currentIndex])) { //number
				entry = readValidNumber();
				try {
					Integer integer = Integer.parseInt(entry);
					token = new SmartScriptToken(
							SmartScriptTokenType.INTEGER, integer);
					
				} catch (NumberFormatException ex) {
					Double decimal = Double.parseDouble(entry);
					token = new SmartScriptToken(
							SmartScriptTokenType.DOUBLE, decimal);
				}
				
			} else if (data[currentIndex] == '+' || data[currentIndex] == '*'
					|| data[currentIndex] == '/' || data[currentIndex] == '^') {
				//operator which is not a minus
				entry = readValidOperator();
				token = new SmartScriptToken(
						SmartScriptTokenType.OPERATOR, entry);
				
			} else if (data[currentIndex] == '-') { //could be start of number
				//or a regular operator
				if (currentIndex + 1 < data.length &&
						Character.isDigit(data[currentIndex+1])) { //number
					entry = readValidNumber();
					try {
						Integer integer = Integer.parseInt(entry);
						token = new SmartScriptToken(
								SmartScriptTokenType.INTEGER, integer);
					} catch (NumberFormatException ex) { //was not integer
						Double decimal = Double.parseDouble(entry);
						token = new SmartScriptToken(
								SmartScriptTokenType.DOUBLE, decimal);
					}
					
				} else { //not a number - an operator
					entry = readValidOperator();
					token = new SmartScriptToken(
							SmartScriptTokenType.OPERATOR, entry);
				}
			}
			return token;
			
		default: //an error occured
			throw new SmartScriptLexerException("Lexer is not in a valid state.");
			
		}
	}
	
	/**
	 * Reads the valid function name, which starts with '@' and continues
	 * with valid variable name.
	 * @return Function name as represented by a string.
	 * @throws SmartScriptLexerException if function name is not valid.
	 */
	private String readValidFunctionName() {
		String validFunctionName;
		
		if (data[currentIndex] != '@') { //not a valid function name
			throw new SmartScriptLexerException("Invalid function name.");
		}
		try {
			currentIndex++;
			validFunctionName = readValidVariableName();
		} catch (SmartScriptLexerException ex) { //invalid function name
			throw new SmartScriptLexerException("Invalid function name.");
		}
		return validFunctionName;
	}
	
	/**
	 * Reads the valid variable name, which stars with a letter and continues
	 * with sequance of letters, digits, or underscores. Causes exception if
	 * valid name could not be read.
	 * @return Valid variable name represented by a <code>String</code>.
	 * @throws SmartScriptLexerException if no valid variable name coudl be read
	 */
	private String readValidVariableName() {
		
		String validVariableName = new String("");
		
		while (currentIndex < data.length) {
			if (validVariableName.isEmpty()) { //first character must be a letter
				if (Character.isLetter(data[currentIndex])) {
					validVariableName += data[currentIndex];
					currentIndex++;
				} else {
					throw new SmartScriptLexerException("Invalid variable name.");
				}
			} else { //can be a letter, a digit or an underscore
				if (Character.isLetter(data[currentIndex]) ||
						Character.isDigit(data[currentIndex]) ||
						data[currentIndex] == '_') {
					validVariableName += data[currentIndex];
					currentIndex++;
				} else {
					break; //valid variable name ends here
				}
			}
		}
		return validVariableName;
	}
	
	/**
	 * Reads a valid operator, which is a single character and can be :
	 * +(plus), -(minus), *(multiplication), /(division) or ^(exponentiation).
	 * Causes an exception if a valid operator could not be read.
	 * @return Valid operator, represented by a <code>String</code>
	 * @throws SmartScriptLexerException if no valid operator could be read.
	 */
	private String readValidOperator() {
		String validOperator = new String("");
		
		if (data[currentIndex] == '+' || data[currentIndex] == '-'
				|| data[currentIndex] == '*' || data[currentIndex] == '/'
				|| data[currentIndex] == '^') {
			validOperator += data[currentIndex];
		} else { //not a valid operator
			throw new SmartScriptLexerException("Invalid operator.");
		}
		currentIndex++;
		return validOperator;
	}
	
	/**
	 * Reads a valid string from inside the tag content String is defined
	 * as a sequence of characters bounded by double quotes. Allowed
	 * escape sequences are '\\'(backslash), '\"'(double quote which is
	 * not the end of the string), '\n'(newline), '\r'(carriage return) 
	 * and '\t'(tab).
	 * @return valid String name
	 * @throws SmartScriptLexerException if no valid string name could be read.
	 */
	private String readValidString() {
		String validString = new String("");
		if (data[currentIndex] != '\"') { //does not start with a quote
			throw new SmartScriptLexerException("Invalid string.");
		} else {
			currentIndex++; //skip quote
			
			//read until the next quote which is not escaped
			while (currentIndex < data.length && data[currentIndex] != '\"') {
				if (data[currentIndex] == '\\') { //escape sequence
					currentIndex++; //skip backslash in input
					if (currentIndex < data.length) {
						if (data[currentIndex] == '\"' || 
							data[currentIndex] == '\\') {
							validString += data[currentIndex];
						} else if (data[currentIndex] == 'n') {
							validString += '\n';
						} else if (data[currentIndex] == 'r') {
							validString += '\r';
						} else if (data[currentIndex] == 't') {
							validString += '\t';
						} else { //not a valid escape sequence
							throw new SmartScriptLexerException("Invalid string.");
						}
						currentIndex++;
					} else {
						throw new SmartScriptLexerException("Invalid string.");
					}
				} else {
					validString += data[currentIndex];
					currentIndex++;
				}
			}
		}
		//check if escape sequence is not finished and is the last character
		if (currentIndex >= data.length || data[currentIndex] != '\"') {
			throw new SmartScriptLexerException("Invalid string.");
		}
		currentIndex++;	//to skip trailing quote
		return validString;
	}
	
	/**
	 * Reads a valid number from the input. Valid numbers are integers
	 * or doubles. Throws an exception if valid number could not be read.
	 * @return String representation of read valid number
	 * @throws SmartScriptLexerException it no valid number was read
	 */
	private String readValidNumber() {
		
		String validNumber = new String("");
		
		while (currentIndex < data.length) {
			//check if first comes a minus sign, or a dot is found
			if (validNumber.isEmpty() && data[currentIndex] == '-' || 
			Character.isDigit(data[currentIndex]) || 
			(Character.isDigit(validNumber.charAt(validNumber.length() - 1))
			&& data[currentIndex] == '.')) {
				
				validNumber += data[currentIndex];
				currentIndex++;
			} else { //check if it's a digit
				if (Character.isDigit(
						validNumber.charAt(validNumber.length() -1))) {
					break;
				} else { //not a digit
					throw new SmartScriptLexerException("Invalid number.");
				}
			}
		}
		return validNumber;
	}
	
	/**
	 * Reads a valid tag ender, which is "$}".
	 * @return valid tag ender in its String representation.
	 * @throws SmartScriptLexerException if no valid tag ender was read.
	 */
	private String readValidTagEnd() {
		String validTagEnd = new String("");
		
		while (currentIndex < data.length) {
			//check if valid tag ender was not yet read fully
			if (validTagEnd.isEmpty() && data[currentIndex] == '$' ||
				validTagEnd.endsWith("$") && data[currentIndex] == '}') {
				validTagEnd += data[currentIndex];
				currentIndex++;
			} else if (validTagEnd.endsWith("}") ) { //tag ender was read
				break;
			} else { //no valid tag ender was read
				throw new SmartScriptLexerException("Invalid tag end.");
			}
		}
		return validTagEnd;
	}
	
	/**
	 * Reads a valid tag name, which is any valid variable name.
	 * @return Uppercase representation of read tag name, because
	 * 	tag names are case-insensitive.
	 * @throws SmartScriptLexerException if no valid tag name coudl be read.
	 */
	private String readValidTagName() {
		String tagName = new String("");
		skipWhitespace();
		
		while (currentIndex < data.length) {
			if (tagName.isEmpty()) { //beginning of tag name
				if (data[currentIndex] == '=') { //valid tag name
					tagName += data[currentIndex];
					currentIndex++;
					break;
					
				} else if (Character.isLetter(data[currentIndex])) {
					//valid beginning of tag name
					tagName += data[currentIndex];
					currentIndex++;
					
				} else { //invalid tag name
					throw new SmartScriptLexerException("Invalid tag name.");
				}
				
			} else { //somewhere in the middle
				
				while (currentIndex < data.length && (
						Character.isLetter(data[currentIndex]) || 
						Character.isDigit(data[currentIndex]) ||
						data[currentIndex] == '_')) {
					
					tagName += data[currentIndex];
					currentIndex++;
				}
				break; 	//tag name was read 
			}
		}
		return tagName.toUpperCase();
	}
	
	/**
	 * Reads valid text, which is everything outside of tag marks in the
	 * document. Allowed escape sequences are '\\' (backslash) and 
	 * '\{' (left curly bracket). Left curly bracket should only be
	 * escaped if it is intended to be followed by '$' sign, because if not,
	 * that combination represents the beginning of a tag and the text reading
	 * will stop there. If Bracket is not followed by the specified sign, it
	 * is treated as a completely normal character.
	 * @return Valid text, represented as a String.
	 * @throws SmartScriptLexerException if no valid text could be read.
	 */
	private String readValidText() {
		String text = new String("");
		
		skipWhitespace();
		while (currentIndex < data.length) {	//to not go out of bounds
			if (data[currentIndex] == '\\') {	//escape sequence
				currentIndex++;		//let's look at the next character
				if (currentIndex >= data.length) {	//there is none
					throw new SmartScriptLexerException
						("Invalid text escape sequence.");
				}
				//TODO - maybe doesn't work ?
				if (data[currentIndex] == '\\' || 
				data[currentIndex] == '{') { //valid escape sequence
					text += (data[currentIndex]);
					currentIndex++;
				} else {	//invalid escape sequence
					throw new SmartScriptLexerException
						("Invalid text escape sequence.");
				}
			} else if (data[currentIndex] == '{') { //maybe tag begins here
				if (currentIndex + 1 < data.length) { //has enough for next char
					if (data[currentIndex+1] == '$') { //tag begins
						if (text.isEmpty()) { //tag is the first thing
							text = "{$";
							currentIndex +=2; //skips the tag mark
							break;
						} else { //already read some text
							break;	//next token will be TAG_BEGIN
						}
					} else { //tag does not begin, bracket is normal character
						text += data[currentIndex];
						currentIndex++;
					}
				}
			} else { //normal character
				text += data[currentIndex];
				currentIndex++;
			}
		}
		return text;
	}
	
	/**
	 * Sets the state of the lexer to the given state.
	 * Intended to be used by the client which uses the lexer.
	 * @param state New state of the lexer.
	 */
	public void setState(SmartScriptLexerState state) {
		this.state = state;
	}
	
}
